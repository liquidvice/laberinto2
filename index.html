<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Alicia en el Laberinto</title>
<style>
  body {
    background: #111;
    margin: 0;
    padding: 0;
    font-family: 'Trebuchet MS', sans-serif;
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #scoreboard {
    margin: 10px;
    font-size: 20px;
    font-weight: bold;
  }
  #gameContainer {
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: flex-start;
    position: relative;
  }
  #mazeCanvas {
    border: 3px solid white;
    background: #222;
    margin: 20px;
  }
  #controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-top: 20px;
  }
  button {
    padding: 10px;
    font-size: 16px;
    border-radius: 8px;
    border: none;
    cursor: pointer;
    background-color: #444;
    color: white;
    transition: 0.3s;
  }
  button:hover {
    background-color: #666;
  }
  #finalMessage {
    font-size: 24px;
    font-weight: bold;
    margin-top: 20px;
    text-align: center;
  }
  #timer {
    position: absolute;
    bottom: 10px;
    right: 10px;
    font-size: 18px;
    font-weight: bold;
    color: #fff;
    background: rgba(0,0,0,0.5);
    padding: 5px 10px;
    border-radius: 8px;
  }
  #warning {
    font-size: 18px;
    font-weight: bold;
    color: yellow;
    margin-top: 10px;
    text-align: center;
  }
</style>
</head>
<body>
  <div id="scoreboard">Nivel: 1 | Puntaje: 0 | Mejor: 0</div>
  <div id="gameContainer">
    <canvas id="mazeCanvas" width="600" height="600"></canvas>
    <div id="controls">
      <button onclick="restartGame()">Reiniciar</button>
      <button onclick="newMaze()">Nuevo laberinto</button>
    </div>
    <div id="timer">Tiempo: 0s | Mejor: 0s</div>
  </div>
  <div id="warning"></div>
  <div id="finalMessage"></div>

<script>
const canvas = document.getElementById("mazeCanvas");
const ctx = canvas.getContext("2d");
const scoreboard = document.getElementById("scoreboard");
const finalMessage = document.getElementById("finalMessage");
const timerDisplay = document.getElementById("timer");
const warning = document.getElementById("warning");

let rows = 10;
let cols = 10;
let cellSize;
let grid = [];
let player = {x:0, y:0};
let goal;
let score = 0;
let bestScore = localStorage.getItem("bestScore") || 0;
let level = 1;
let maxLevel = 5; 
let teas = [];

let startTime;
let elapsedTime = 0;
let bestTime = localStorage.getItem("bestTime") || 0;
let timerInterval;

class Cell {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.walls = [true, true, true, true];
    this.visited = false;
  }
  draw() {
    let x = this.x * cellSize;
    let y = this.y * cellSize;
    ctx.strokeStyle = "white";
    ctx.lineWidth = 2;
    if (this.walls[0]) drawLine(x, y, x + cellSize, y);
    if (this.walls[1]) drawLine(x + cellSize, y, x + cellSize, y + cellSize);
    if (this.walls[2]) drawLine(x + cellSize, y + cellSize, x, y + cellSize);
    if (this.walls[3]) drawLine(x, y + cellSize, x, y);
  }
}

function drawLine(x1, y1, x2, y2) {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
}

function setupMaze(keepPositions=false) {
  cellSize = Math.floor(canvas.width / cols);
  grid = [];
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      grid.push(new Cell(x, y));
    }
  }
  if (!keepPositions) {
    player = {x:0, y:0};
    goal = {x: cols-1, y: rows-1};
    teas = [];
    for (let i=0; i<Math.floor(rows/2); i++) {
      teas.push({x: Math.floor(Math.random()*cols), y: Math.floor(Math.random()*rows)});
    }
  }
  grid.forEach(c => c.visited=false);
  generateMaze(grid[0]);
  drawMaze();
  if (level === 1 && !keepPositions) {
    elapsedTime = 0;
    startTime = Date.now();
    clearInterval(timerInterval);
    timerInterval = setInterval(() => {
      elapsedTime = Math.floor((Date.now() - startTime) / 1000);
      updateScoreboard();
    }, 1000);
  }
  updateScoreboard();
}

function index(x, y) {
  if (x < 0 || y < 0 || x > cols-1 || y > rows-1) return -1;
  return x + y * cols;
}

function generateMaze(cell) {
  cell.visited = true;
  let neighbors = [
    {cell: grid[index(cell.x, cell.y-1)], dir:0},
    {cell: grid[index(cell.x+1, cell.y)], dir:1},
    {cell: grid[index(cell.x, cell.y+1)], dir:2},
    {cell: grid[index(cell.x-1, cell.y)], dir:3}
  ];
  neighbors = neighbors.filter(n => n.cell && !n.cell.visited);
  while (neighbors.length > 0) {
    let next = neighbors[Math.floor(Math.random()*neighbors.length)];
    cell.walls[next.dir] = false;
    next.cell.walls[(next.dir+2)%4] = false;
    generateMaze(next.cell);
    neighbors = [
      {cell: grid[index(cell.x, cell.y-1)], dir:0},
      {cell: grid[index(cell.x+1, cell.y)], dir:1},
      {cell: grid[index(cell.x, cell.y+1)], dir:2},
      {cell: grid[index(cell.x-1, cell.y)], dir:3}
    ].filter(n => n.cell && !n.cell.visited);
  }
}

function modifyMaze() {
  // Dificultar caminos cerrando un 50% de los pasillos hacia la taza mÃ¡s cercana
  let nearestTea = teas[0];
  let minDist = Infinity;
  teas.forEach(t => {
    let d = Math.abs(t.x - player.x) + Math.abs(t.y - player.y);
    if (d < minDist) {
      minDist = d;
      nearestTea = t;
    }
  });

  for (let i=0; i<grid.length; i++) {
    if (Math.random() < 0.5) { 
      let c = grid[i];
      let wallToClose = Math.floor(Math.random()*4);
      c.walls[wallToClose] = true;
    }
  }
}

function drawMaze() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  grid.forEach(c => c.draw());
  
  // Jugador
  ctx.font = `${cellSize*0.7}px Arial`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("ðŸ‘¸", player.x*cellSize + cellSize/2, player.y*cellSize + cellSize/2);

  // Meta
  ctx.fillStyle = "red";
  ctx.fillRect(goal.x*cellSize+cellSize*0.25, goal.y*cellSize+cellSize*0.25, cellSize*0.5, cellSize*0.5);
  
  // Tazas
  ctx.font = `${cellSize*0.5}px Arial`;
  teas.forEach(t => {
    ctx.fillText("â˜•", t.x*cellSize + cellSize/2, t.y*cellSize + cellSize/2);
  });
}

document.addEventListener("keydown", movePlayer);

function movePlayer(e) {
  let dx=0, dy=0;
  if (e.key=="ArrowUp") dy=-1;
  if (e.key=="ArrowDown") dy=1;
  if (e.key=="ArrowLeft") dx=-1;
  if (e.key=="ArrowRight") dx=1;
  let current = grid[index(player.x, player.y)];
  if (dx==0 && dy==-1 && !current.walls[0]) player.y--;
  if (dx==1 && dy==0 && !current.walls[1]) player.x++;
  if (dx==0 && dy==1 && !current.walls[2]) player.y++;
  if (dx==-1 && dy==0 && !current.walls[3]) player.x--;

  let collected = [];
  teas = teas.filter(t => {
    if (t.x==player.x && t.y==player.y) {
      score+=10;
      collected.push(t);
      updateScoreboard();
      return false;
    }
    return true;
  });

  // ðŸ”¥ Desde nivel 4 en adelante: modificar muros al tomar taza
  if (collected.length > 0 && level >= 4) {
    modifyMaze();
  }

  if (player.x==goal.x && player.y==goal.y) {
    if (teas.length > 0) {
      warning.textContent = "âš ï¸ Te faltan tazas por recoger";
      setTimeout(() => { warning.textContent = ""; }, 2000);
    } else {
      warning.textContent = "";
      if (level < maxLevel) {
        level++;
        rows += 2;
        cols += 2;
        setupMaze();
      } else {
        clearInterval(timerInterval);
        if (elapsedTime < bestTime || bestTime == 0) {
          bestTime = elapsedTime;
          localStorage.setItem("bestTime", bestTime);
        }
        if (score > bestScore) {
          bestScore = score;
          localStorage.setItem("bestScore", bestScore);
        }
        finalMessage.innerHTML = `ðŸŽ‰ Â¡Ganaste! Puntaje: ${score} | Mejor: ${bestScore} | Tiempo total: ${elapsedTime}s | Mejor tiempo: ${bestTime}s`;
      }
    }
  }
  drawMaze();
}

function restartGame() {
  score = 0;
  level = 1;
  rows = 10;
  cols = 10;
  finalMessage.innerHTML = "";
  setupMaze();
}

function newMaze() {
  setupMaze();
}

function updateScoreboard() {
  scoreboard.textContent = `Nivel: ${level} | Puntaje: ${score} | Mejor: ${bestScore}`;
  timerDisplay.textContent = `Tiempo: ${elapsedTime}s | Mejor: ${bestTime}s`;
}

setupMaze();
</script>
</body>
</html>

