<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Alicia en el Laberinto — Nivel 6 Oscilante</title>
<style>
  :root{
    --panel:#0f0f12;
    --accent:#8a2be2;
    --white:#ffffff;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:linear-gradient(#070708,#0b0b0e);color:#fff;font-family:"Trebuchet MS",sans-serif}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:14px}
  h1{margin:6px 0 8px}
  #scoreboard{margin:6px;font-weight:bold}
  #gameRow{display:flex;gap:16px;align-items:flex-start;position:relative}
  canvas{background:var(--panel);border:3px solid var(--white);display:block;transform-origin:center center;z-index:2}
  #controls{display:flex;flex-direction:column;gap:8px;z-index:3}
  button{padding:8px 12px;border-radius:8px;border:none;background:var(--accent);color:#fff;cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,0.6)}
  #finalMessage{margin-top:12px;font-weight:bold;text-align:center}
  #warning{color:yellow;margin-top:6px}
  #enterWonderland{
    display:none;
    margin-top:12px;
    background:linear-gradient(270deg,#ff00ff,#00ffff,#ffcc00,#ff00ff);
    background-size:600% 600%;
    animation:shift 5s linear infinite;
    color:black;padding:10px 18px;border-radius:14px;border:2px solid #fff;font-weight:700;box-shadow:0 0 16px #fff;z-index:3
  }
  @keyframes shift{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}
  #hud{margin-top:8px;font-size:14px}
  @media (max-width:900px){ canvas{width:90vw;height:90vw} }
</style>
</head>
<body>
<div class="wrap">
  <h1>🌀 Alicia en el Laberinto</h1>
  <div id="scoreboard">Nivel: 1 | Puntaje: 0 | Mejor: 0</div>

  <div id="gameRow">
    <canvas id="mazeCanvas" width="600" height="600"></canvas>

    <div id="controls">
      <button id="btnRestart">Reiniciar</button>
      <button id="btnNew">Nuevo laberinto</button>
      <div id="timer" style="margin-top:8px">Tiempo: 0s</div>
      <div id="warning"></div>
    </div>
  </div>

  <div id="finalMessage"></div>
  <button id="enterWonderland">🌈 Entrar al País de las Maravillas 🌈</button>
  <div id="hud">
    <span id="scoreDisplay">Puntaje: 0</span> · <span id="bestDisplay">Mejor: 0</span>
  </div>
</div>

<script>
/* ------------------------------
   Estado global y referencias
   ------------------------------*/
const canvas = document.getElementById('mazeCanvas');
const ctx = canvas.getContext('2d');
const scoreboard = document.getElementById('scoreboard');
const finalMessage = document.getElementById('finalMessage');
const warning = document.getElementById('warning');
const enterBtn = document.getElementById('enterWonderland');
const btnRestart = document.getElementById('btnRestart');
const btnNew = document.getElementById('btnNew');
const timerEl = document.getElementById('timer');
const scoreEl = document.getElementById('scoreDisplay');
const bestEl = document.getElementById('bestDisplay');

let rows = 10, cols = 10;
let cellSize = 0;
let grid = [];
let player = {x:0,y:0};
let goal = {x:0,y:0};
let teas = [];
let score = 0;
let bestScore = Number(localStorage.getItem('bestScore')||0);
let level = 1;
let maxLevel = 5;

let startTime = null;
let elapsedTime = 0;
let timerInterval = null;

/* Wonderland flags */
let isWonderland = false;
let rafId = null;
let cheshireInterval = null;
let cheshirePos = null;
let cheshireVisible = true;
let disappearing = false;

/* Oscillation parameters (level 6) */
let oscAmplitude = 0.25; // radians max amplitude (about 14 degrees) - will be raised for faster feel
let oscFrequency = 0.0025; // controls speed; higher => faster oscillation (time-based multiplier)
let oscStart = performance.now(); // base time

/* We'll choose a stronger oscillation so it "feels faster" but still playable:
   user asked "gire rapido pero no imposible" and later "oscile".
   We'll increase amplitude moderate and frequency moderate.
*/
let targetAmplitude = 0.5; // ~29 degrees max (playable)
let targetFrequency = 0.0045; // somewhat quicker oscillation

/* ------------------------------
   Helpers: Cell, index, random
   ------------------------------*/
class Cell {
  constructor(x,y){
    this.x=x; this.y=y;
    this.walls=[true,true,true,true]; // top,right,bottom,left
    this.visited=false;
  }
}
function idx(x,y){
  if(x<0||y<0||x>=cols||y>=rows) return -1;
  return x + y*cols;
}
function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

/* ------------------------------
   Maze generation (DFS stack)
   ------------------------------*/
function generateMazeDFS(){
  grid.forEach(c=>c.visited=false);
  const stack = [];
  const start = grid[0];
  start.visited = true;
  stack.push(start);
  while(stack.length>0){
    const current = stack[stack.length-1];
    const x = current.x, y = current.y;
    const neighbors = [];
    const top = grid[idx(x,y-1)];
    const right = grid[idx(x+1,y)];
    const bottom = grid[idx(x,y+1)];
    const left = grid[idx(x-1,y)];
    if(top && !top.visited) neighbors.push({cell:top,dir:0});
    if(right && !right.visited) neighbors.push({cell:right,dir:1});
    if(bottom && !bottom.visited) neighbors.push({cell:bottom,dir:2});
    if(left && !left.visited) neighbors.push({cell:left,dir:3});
    if(neighbors.length>0){
      const next = neighbors[Math.floor(Math.random()*neighbors.length)];
      current.walls[next.dir]=false;
      next.cell.walls[(next.dir+2)%4]=false;
      next.cell.visited = true;
      stack.push(next.cell);
    } else {
      stack.pop();
    }
  }
}

/* ------------------------------
   Setup maze, teas, timers
   ------------------------------*/
function setupMaze(){
  cellSize = Math.floor(canvas.width / cols);
  grid = [];
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      grid.push(new Cell(x,y));
    }
  }
  player = {x:0,y:0};
  goal = {x:cols-1,y:rows-1};

  // place teas (not start/goal)
  teas = [];
  const nTeas = Math.max(3, Math.floor(rows/2));
  for(let i=0;i<nTeas;i++){
    let tx,ty;
    do {
      tx = Math.floor(Math.random()*cols);
      ty = Math.floor(Math.random()*rows);
    } while ((tx===player.x && ty===player.y) || (tx===goal.x && ty===goal.y));
    teas.push({x:tx,y:ty});
  }

  generateMazeDFS();

  // normal timer for levels 1-5
  if(!isWonderland){
    stopWonderland(); // cleanup if leftover
    elapsedTime = 0;
    startTime = Date.now();
    if(timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(()=>{
      elapsedTime = Math.floor((Date.now() - startTime)/1000);
      updateScoreboard();
    },1000);
  }

  drawMazeOnce();
  updateScoreboard();
}

/* ------------------------------
   Drawing helpers
   ------------------------------*/
function drawLine(x1,y1,x2,y2){
  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(x2,y2);
  ctx.stroke();
}

/* Draw initial / non-animated frame or for levels 1-5 */
function drawMazeOnce(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  if(isWonderland){
    // compute current oscillation angle from time (so angle not accumulated)
    const t = performance.now() - oscStart;
    const angle = oscAmplitude * Math.sin(t * targetFrequency * 2 * Math.PI);
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2);
    ctx.rotate(angle);
    ctx.translate(-canvas.width/2, -canvas.height/2);
  }

  // draw static psychedelic heat-style background (inside canvas)
  drawHeatBackgroundStatic();

  // draw walls
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 2;
  for(const c of grid){
    const x = c.x*cellSize, y = c.y*cellSize;
    if(c.walls[0]) drawLine(x,y,x+cellSize,y);
    if(c.walls[1]) drawLine(x+cellSize,y,x+cellSize,y+cellSize);
    if(c.walls[2]) drawLine(x+cellSize,y+cellSize,x,y+cellSize);
    if(c.walls[3]) drawLine(x,y+cellSize,x,y);
  }

  // draw teas
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.font = `${Math.floor(cellSize*0.55)}px Arial`;
  for(const t of teas){
    if(isWonderland){
      const alpha = 0.15 + 0.85*Math.abs(Math.sin((Date.now()/80) + (t.x + t.y)));
      ctx.globalAlpha = alpha;
      ctx.fillStyle = Math.random()>0.5 ? "#ff66ff" : "#66ffea";
    } else {
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#ffff88";
    }
    ctx.fillText("☕", t.x*cellSize + cellSize/2, t.y*cellSize + cellSize/2);
  }
  ctx.globalAlpha = 1;

  // draw player
  ctx.font = `${Math.floor(cellSize*0.75)}px Arial`;
  ctx.fillStyle = "#ffff77";
  ctx.fillText("👸", player.x*cellSize + cellSize/2, player.y*cellSize + cellSize/2);

  // draw goal
  ctx.fillStyle = isWonderland ? "#00ff88" : "#ff4444";
  ctx.fillRect(goal.x*cellSize + cellSize*0.2, goal.y*cellSize + cellSize*0.2, cellSize*0.6, cellSize*0.6);

  // draw cheshire if applicable
  if(isWonderland && cheshirePos && cheshireVisible){
    ctx.font = `${Math.floor(cellSize*0.9)}px Arial`;
    ctx.fillStyle = "#fff";
    ctx.fillText("😸", cheshirePos.x*cellSize + cellSize/2, cheshirePos.y*cellSize + cellSize/2 - (cellSize*0.05));
  }

  if(isWonderland) ctx.restore();
}

/* ------------------------------
   Static heat-like background drawing
   (drawn inside canvas; does not move)
   ------------------------------*/
function drawHeatBackgroundStatic(){
  const w = canvas.width, h = canvas.height;
  const rg = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.05, w/2, h/2, Math.max(w,h)*0.75);
  rg.addColorStop(0, "rgba(255,200,100,0.22)");
  rg.addColorStop(0.15, "rgba(255,120,50,0.16)");
  rg.addColorStop(0.30, "rgba(255,60,160,0.12)");
  rg.addColorStop(0.45, "rgba(160,60,255,0.10)");
  rg.addColorStop(0.60, "rgba(60,200,255,0.08)");
  rg.addColorStop(0.75, "rgba(100,255,120,0.06)");
  rg.addColorStop(1, "rgba(255,255,255,0.02)");
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = rg;
  ctx.fillRect(0,0,w,h);

  ctx.globalCompositeOperation = 'overlay';
  const rings = 6;
  for(let i=1;i<=rings;i++){
    const alpha = 0.03 * (1 - i/rings);
    ctx.beginPath();
    ctx.arc(w/2, h/2, (i * Math.min(w,h) * 0.12), 0, Math.PI*2);
    ctx.strokeStyle = `rgba(${Math.floor(200 - i*20)},${Math.floor(100 + i*20)},${Math.floor(150 + i*10)},${alpha})`;
    ctx.lineWidth = 30;
    ctx.stroke();
  }
  ctx.restore();
}

/* ------------------------------
   Wonderland animation (oscillatory rotation)
   ------------------------------*/
function wonderlandLoop(){
  if(!isWonderland) return;
  const t = performance.now() - oscStart;
  const angle = targetAmplitude * Math.sin(t * targetFrequency * 2 * Math.PI);
  rotationAngle = angle;

  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.save();
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.rotate(rotationAngle);
  ctx.translate(-canvas.width/2, -canvas.height/2);

  drawHeatBackgroundStatic();

  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 2;
  for(const c of grid){
    const x = c.x*cellSize, y=c.y*cellSize;
    if(c.walls[0]) drawLine(x,y,x+cellSize,y);
    if(c.walls[1]) drawLine(x+cellSize,y,x+cellSize,y+cellSize);
    if(c.walls[2]) drawLine(x+cellSize,y+cellSize,x,y+cellSize);
    if(c.walls[3]) drawLine(x,y+cellSize,x,y);
  }

  ctx.font = `${Math.floor(cellSize*0.55)}px Arial`;
  for(const tcell of teas){
    const alpha = 0.12 + 0.88 * Math.abs(Math.sin((Date.now()/70) + (tcell.x + tcell.y)));
    ctx.globalAlpha = alpha;
    const color = Math.random() > 0.5 ? "#ff66ff" : "#66ffea";
    ctx.fillStyle = color;
    ctx.fillText("☕", tcell.x*cellSize + cellSize/2, tcell.y*cellSize + cellSize/2);
  }
  ctx.globalAlpha = 1;

  ctx.font = `${Math.floor(cellSize*0.75)}px Arial`;
  ctx.fillStyle = "#ffff77";
  ctx.fillText("👸", player.x*cellSize + cellSize/2, player.y*cellSize + cellSize/2);

  ctx.fillStyle = "lime";
  ctx.fillRect(goal.x*cellSize + cellSize*0.2, goal.y*cellSize + cellSize*0.2, cellSize*0.6, cellSize*0.6);

  if(cheshirePos && cheshireVisible){
    ctx.font = `${Math.floor(cellSize*0.9)}px Arial`;
    ctx.fillStyle = "#fff";
    ctx.fillText("😸", cheshirePos.x*cellSize + cellSize/2, cheshirePos.y*cellSize + cellSize/2 - (cellSize*0.05));
  }

  ctx.restore();

  if(disappearing){
    canvas.style.opacity = Math.max(0, (parseFloat(canvas.style.opacity||1) - 0.01));
  }

  rafId = requestAnimationFrame(wonderlandLoop);
}

/* ------------------------------
   Input & movement (works while canvas rotates)
   ------------------------------*/
function onKeyDownMain(e){
  if(disappearing) return;
  let dx=0, dy=0;
  if(e.key === 'ArrowUp') dy = -1;
  if(e.key === 'ArrowDown') dy = 1;
  if(e.key === 'ArrowLeft') dx = -1;
  if(e.key === 'ArrowRight') dx = 1;

  if(isWonderland){
    dx = -dx; dy = -dy;
  }

  const cur = grid[idx(player.x, player.y)];
  if(dx===0 && dy===-1 && !cur.walls[0]) player.y--;
  if(dx===1 && dy===0 && !cur.walls[1]) player.x++;
  if(dx===0 && dy===1 && !cur.walls[2]) player.y++;
  if(dx===-1 && dy===0 && !cur.walls[3]) player.x--;

  if(player.x < 0) player.x = 0;
  if(player.x > cols-1) player.x = cols-1;
  if(player.y < 0) player.y = 0;
  if(player.y > rows-1) player.y = rows-1;

  for(let i=teas.length-1;i>=0;i--){
    if(teas[i].x === player.x && teas[i].y === player.y){
      teas.splice(i,1);
      score += 10;
      updateScoreboard();
    }
  }

  if(player.x === goal.x && player.y === goal.y){
    if(teas.length > 0){
      warning.innerText = "⚠️ Te faltan tazas por recoger";
      setTimeout(()=> warning.innerText = "", 1600);
    } else {
      level++;
      if(level > maxLevel){
        stopWonderland();
        finalMessage.innerHTML = "¡Ganaste el laberinto! 🎉";
        return;
      }
      setupMaze();
    }
  }

  drawMazeOnce();
}

function updateScoreboard(){
  scoreEl.innerText = `Puntaje: ${score}`;
  bestEl.innerText = `Mejor: ${bestScore}`;
  scoreboard.innerHTML = `Nivel: ${level} | Puntaje: ${score} | Mejor: ${bestScore}`;
}

function stopWonderland(){
  isWonderland = false;
  cancelAnimationFrame(rafId);
  clearInterval(cheshireInterval);
}

function startWonderland(){
  isWonderland = true;
  oscStart = performance.now();
  setupMaze();
  wonderlandLoop();
}

document.addEventListener("keydown",onKeyDownMain);
btnRestart.addEventListener("click",()=>setupMaze());
btnNew.addEventListener("click",()=>{ setupMaze(); });

</script>
</body>
</html>
